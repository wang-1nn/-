{"version":3,"file":"vue3-virtual-scroller.min.js","sources":["../src/config.js","../node_modules/vue3-resize/dist/vue3-resize.esm.js","../node_modules/vue3-observe-visibility2/dist/vue3-observe-visibility2.esm.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.js","../src/index.js"],"sourcesContent":["export default {\r\n  itemsLimit: 1000,\r\n}\r\n","import { ref, onMounted, onBeforeUnmount, openBlock, createBlock } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  const ua = window.navigator.userAgent;\n  const msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  const trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    const rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  const edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat() {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n  props: {\n    showTrigger: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['notify'],\n\n  setup(props, {\n    emit\n  }) {\n    let _w = 0;\n    let _h = 0;\n    const elRef = ref(null);\n    let _resizeObject = null;\n\n    const compareAndNotify = () => {\n      if (_w !== elRef.value.offsetWidth || _h !== elRef.value.offsetHeight) {\n        _w = elRef.value.offsetWidth;\n        _h = elRef.value.offsetHeight;\n        emit('notify', {\n          width: _w,\n          height: _h\n        });\n      }\n    };\n\n    const addResizeHandlers = () => {\n      _resizeObject.contentDocument.defaultView.addEventListener('resize', compareAndNotify);\n\n      compareAndNotify();\n    };\n\n    const removeResizeHandlers = () => {\n      if (_resizeObject && _resizeObject.onload) {\n        if (!isIE && _resizeObject.contentDocument) {\n          _resizeObject.contentDocument.defaultView.removeEventListener('resize', compareAndNotify);\n        }\n\n        elRef.value.removeChild(_resizeObject);\n        _resizeObject.onload = null;\n        _resizeObject = null;\n      }\n    };\n\n    onMounted(() => {\n      initCompat();\n      _w = elRef.value.offsetWidth;\n      _h = elRef.value.offsetHeight;\n      const object = document.createElement('object');\n      _resizeObject = object;\n      object.setAttribute('aria-hidden', 'true');\n      object.setAttribute('tabindex', '-1');\n      object.onload = addResizeHandlers;\n      object.type = 'text/html';\n\n      if (isIE) {\n        elRef.value.appendChild(object);\n      }\n\n      object.data = 'about:blank';\n\n      if (!isIE) {\n        elRef.value.appendChild(object);\n      }\n\n      if (props.showTrigger) {\n        compareAndNotify();\n      }\n    });\n    onBeforeUnmount(() => {\n      removeResizeHandlers();\n    });\n    return {\n      elRef\n    };\n  }\n\n};\n\nconst _hoisted_1 = {\n  ref: \"elRef\",\n  class: \"vue3-resize-observer\",\n  tabindex: \"-1\"\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createBlock(\"div\", _hoisted_1, null, 512\n  /* NEED_PATCH */\n  );\n}\n\nscript.render = render;\nscript.__file = \"src/package/ResizeObserver/ResizeObserver.vue\";\n\nscript.install = function (app) {\n  app.component(script.name, script);\n};\n\nvar version = \"0.2.0\";\n\nconst install = app => {\n  app.use(script);\n}; // Plugin\n\n\nconst Vue3Resize = {\n  version,\n  install\n};\n\nexport default Vue3Resize;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue3-resize.esm.js.map\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState =\n/*#__PURE__*/\nfunction () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      setTimeout(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && this.options.intersection.threshold || 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction mounted(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nfunction componentUpdated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    mounted(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nvar ObserveVisibility = {\n  mounted: mounted,\n  componentUpdated: componentUpdated,\n  unmounted: unmounted\n};\n\nvar version = \"0.0.3\";\n\nvar install = function install(app) {\n  app.use({\n    // eslint-disable-next-line no-shadow\n    install: function install(app) {\n      app.directive('observe-visibility', ObserveVisibility);\n    }\n  });\n}; // Plugin\n\n\nvar plugin = {\n  version: version,\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","export const props = {\r\n  items: {\r\n    type: Array,\r\n    required: true,\r\n  },\r\n\r\n  keyField: {\r\n    type: String,\r\n    default: 'id',\r\n  },\r\n\r\n  direction: {\r\n    type: String,\r\n    default: 'vertical',\r\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\r\n  },\r\n}\r\n\r\nexport const scrollParent = (node) => {\r\n  const regex = /(auto|scroll)/;\r\n\r\n  function parents (node, ps) {\r\n    if (node.parentNode === null) { return ps; }\r\n    return parents(node.parentNode, ps.concat([node]));\r\n  }\r\n\r\n  function style (node, prop) {\r\n    return getComputedStyle(node, null).getPropertyValue(prop);\r\n  }\r\n\r\n  function overflow (node) {\r\n    return style(node, \"overflow\") + style(node, \"overflow-y\") + style(node, \"overflow-x\");\r\n  }\r\n\r\n  function scroll (node) {\r\n    return regex.test(overflow(node));\r\n  }\r\n\r\n  function scrollParent (node) {\r\n    if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\r\n      return ;\r\n    }\r\n\r\n    const ps = parents(node.parentNode, []);\r\n\r\n    for (let i = 0; i < ps.length; i += 1) {\r\n      if (scroll(ps[i])) {\r\n        return ps[i];\r\n      }\r\n    }\r\n\r\n    return document.scrollingElement || document.documentElement;\r\n  }\r\n\r\n  return scrollParent(node);\r\n}\r\n\r\nexport function simpleArray () {\r\n  return this.items.length && typeof this.items[0] !== 'object'\r\n}\r\n","export let supportsPassive = false\r\n\r\nif (typeof window !== 'undefined') {\r\n  supportsPassive = false\r\n  try {\r\n    var opts = Object.defineProperty({}, 'passive', {\r\n      get () {\r\n        supportsPassive = true\r\n      },\r\n    })\r\n    window.addEventListener('test', null, opts)\r\n  } catch (e) {}\r\n}\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ResizeObserver } from 'vue3-resize'\r\nimport { ObserveVisibility } from 'vue3-observe-visibility2'\r\nimport config from '../config'\r\nimport { props, simpleArray, scrollParent } from './common'\r\nimport {supportsPassive} from '../utils'\r\nimport {defineComponent} from 'vue'\r\n\r\nlet uid = 0\r\n\r\nexport default defineComponent({\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  emits: ['visible', 'hidden', 'resize', 'update'],\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = {\r\n        item,\r\n        position: 0,\r\n      }\r\n      view.nr = {\r\n        id: uid++,\r\n        index,\r\n        used: true,\r\n        key,\r\n        type,\r\n      }\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = scrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n})\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    v-observe-visibility=\"handleVisibilityChange\"\r\n    class=\"vue-recycle-scroller\"\r\n    :class=\"{\r\n      ready,\r\n      'page-mode': pageMode,\r\n      [`direction-${direction}`]: true,\r\n    }\"\r\n    @scroll.passive=\"handleScroll\"\r\n  >\r\n    <div\r\n      v-if=\"$slots.before\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"before\"\r\n      />\r\n    </div>\r\n\r\n    <div\r\n      ref=\"wrapper\"\r\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\r\n      class=\"vue-recycle-scroller__item-wrapper\"\r\n    >\r\n      <div\r\n        v-for=\"view of pool\"\r\n        :key=\"view.nr.id\"\r\n        :style=\"ready ? { transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px)` } : null\"\r\n        class=\"vue-recycle-scroller__item-view\"\r\n        :class=\"{ hover: hoverKey === view.nr.key }\"\r\n        @mouseenter=\"hoverKey = view.nr.key\"\r\n        @mouseleave=\"hoverKey = null\"\r\n      >\r\n        <slot\r\n          :item=\"view.item\"\r\n          :index=\"view.nr.index\"\r\n          :active=\"view.nr.used\"\r\n        />\r\n      </div>\r\n    </div>\r\n\r\n    <div\r\n      v-if=\"$slots.after\"\r\n      class=\"vue-recycle-scroller__slot\"\r\n    >\r\n      <slot\r\n        name=\"after\"\r\n      />\r\n    </div>\r\n\r\n    <ResizeObserver @notify=\"handleResize\" />\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ResizeObserver } from 'vue3-resize'\r\nimport { ObserveVisibility } from 'vue3-observe-visibility2'\r\nimport config from '../config'\r\nimport { props, simpleArray, scrollParent } from './common'\r\nimport {supportsPassive} from '../utils'\r\nimport {defineComponent} from 'vue'\r\n\r\nlet uid = 0\r\n\r\nexport default defineComponent({\r\n  name: 'RecycleScroller',\r\n\r\n  components: {\r\n    ResizeObserver,\r\n  },\r\n\r\n  directives: {\r\n    ObserveVisibility,\r\n  },\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    itemSize: {\r\n      type: Number,\r\n      default: null,\r\n    },\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      default: null,\r\n    },\r\n\r\n    sizeField: {\r\n      type: String,\r\n      default: 'size',\r\n    },\r\n\r\n    typeField: {\r\n      type: String,\r\n      default: 'type',\r\n    },\r\n\r\n    buffer: {\r\n      type: Number,\r\n      default: 200,\r\n    },\r\n\r\n    pageMode: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    prerender: {\r\n      type: Number,\r\n      default: 0,\r\n    },\r\n\r\n    emitUpdate: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n  },\r\n\r\n  emits: ['visible', 'hidden', 'resize', 'update'],\r\n\r\n  data () {\r\n    return {\r\n      pool: [],\r\n      totalSize: 0,\r\n      ready: false,\r\n      hoverKey: null,\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    sizes () {\r\n      if (this.itemSize === null) {\r\n        const sizes = {\r\n          '-1': { accumulator: 0 },\r\n        }\r\n        const items = this.items\r\n        const field = this.sizeField\r\n        const minItemSize = this.minItemSize\r\n        let computedMinSize = 10000\r\n        let accumulator = 0\r\n        let current\r\n        for (let i = 0, l = items.length; i < l; i++) {\r\n          current = items[i][field] || minItemSize\r\n          if (current < computedMinSize) {\r\n            computedMinSize = current\r\n          }\r\n          accumulator += current\r\n          sizes[i] = { accumulator, size: current }\r\n        }\r\n        // eslint-disable-next-line\r\n        this.$_computedMinItemSize = computedMinSize\r\n        return sizes\r\n      }\r\n      return []\r\n    },\r\n\r\n    simpleArray,\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.updateVisibleItems(true)\r\n    },\r\n\r\n    pageMode () {\r\n      this.applyPageMode()\r\n      this.updateVisibleItems(false)\r\n    },\r\n\r\n    sizes: {\r\n      handler () {\r\n        this.updateVisibleItems(false)\r\n      },\r\n      deep: true,\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_startIndex = 0\r\n    this.$_endIndex = 0\r\n    this.$_views = new Map()\r\n    this.$_unusedViews = new Map()\r\n    this.$_scrollDirty = false\r\n    this.$_lastUpdateScrollPosition = 0\r\n\r\n    // In SSR mode, we also prerender the same number of item for the first render\r\n    // to avoir mismatch between server and client templates\r\n    if (this.prerender) {\r\n      this.$_prerender = true\r\n      this.updateVisibleItems(false)\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    this.applyPageMode()\r\n    this.$nextTick(() => {\r\n      // In SSR mode, render the real number of visible items\r\n      this.$_prerender = false\r\n      this.updateVisibleItems(true)\r\n      this.ready = true\r\n    })\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.removeListeners()\r\n  },\r\n\r\n  methods: {\r\n    addView (pool, index, item, key, type) {\r\n      const view = {\r\n        item,\r\n        position: 0,\r\n      }\r\n      view.nr = {\r\n        id: uid++,\r\n        index,\r\n        used: true,\r\n        key,\r\n        type,\r\n      }\r\n      pool.push(view)\r\n      return view\r\n    },\r\n\r\n    unuseView (view, fake = false) {\r\n      const unusedViews = this.$_unusedViews\r\n      const type = view.nr.type\r\n      let unusedPool = unusedViews.get(type)\r\n      if (!unusedPool) {\r\n        unusedPool = []\r\n        unusedViews.set(type, unusedPool)\r\n      }\r\n      unusedPool.push(view)\r\n      if (!fake) {\r\n        view.nr.used = false\r\n        view.position = -9999\r\n        this.$_views.delete(view.nr.key)\r\n      }\r\n    },\r\n\r\n    handleResize () {\r\n      this.$emit('resize')\r\n      if (this.ready) this.updateVisibleItems(false)\r\n    },\r\n\r\n    handleScroll (event) {\r\n      if (!this.$_scrollDirty) {\r\n        this.$_scrollDirty = true\r\n        requestAnimationFrame(() => {\r\n          this.$_scrollDirty = false\r\n          const { continuous } = this.updateVisibleItems(false, true)\r\n\r\n          // It seems sometimes chrome doesn't fire scroll event :/\r\n          // When non continous scrolling is ending, we force a refresh\r\n          if (!continuous) {\r\n            clearTimeout(this.$_refreshTimout)\r\n            this.$_refreshTimout = setTimeout(this.handleScroll, 100)\r\n          }\r\n        })\r\n      }\r\n    },\r\n\r\n    handleVisibilityChange (isVisible, entry) {\r\n      if (this.ready) {\r\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\r\n          this.$emit('visible')\r\n          requestAnimationFrame(() => {\r\n            this.updateVisibleItems(false)\r\n          })\r\n        } else {\r\n          this.$emit('hidden')\r\n        }\r\n      }\r\n    },\r\n\r\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\r\n      const itemSize = this.itemSize\r\n      const minItemSize = this.$_computedMinItemSize\r\n      const typeField = this.typeField\r\n      const keyField = this.simpleArray ? null : this.keyField\r\n      const items = this.items\r\n      const count = items.length\r\n      const sizes = this.sizes\r\n      const views = this.$_views\r\n      const unusedViews = this.$_unusedViews\r\n      const pool = this.pool\r\n      let startIndex, endIndex\r\n      let totalSize\r\n\r\n      if (!count) {\r\n        startIndex = endIndex = totalSize = 0\r\n      } else if (this.$_prerender) {\r\n        startIndex = 0\r\n        endIndex = this.prerender\r\n        totalSize = null\r\n      } else {\r\n        const scroll = this.getScroll()\r\n\r\n        // Skip update if use hasn't scrolled enough\r\n        if (checkPositionDiff) {\r\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\r\n          if (positionDiff < 0) positionDiff = -positionDiff\r\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\r\n            return {\r\n              continuous: true,\r\n            }\r\n          }\r\n        }\r\n        this.$_lastUpdateScrollPosition = scroll.start\r\n\r\n        const buffer = this.buffer\r\n        scroll.start -= buffer\r\n        scroll.end += buffer\r\n\r\n        // Variable size mode\r\n        if (itemSize === null) {\r\n          let h\r\n          let a = 0\r\n          let b = count - 1\r\n          let i = ~~(count / 2)\r\n          let oldI\r\n\r\n          // Searching for startIndex\r\n          do {\r\n            oldI = i\r\n            h = sizes[i].accumulator\r\n            if (h < scroll.start) {\r\n              a = i\r\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\r\n              b = i\r\n            }\r\n            i = ~~((a + b) / 2)\r\n          } while (i !== oldI)\r\n          i < 0 && (i = 0)\r\n          startIndex = i\r\n\r\n          // For container style\r\n          totalSize = sizes[count - 1].accumulator\r\n\r\n          // Searching for endIndex\r\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\r\n          if (endIndex === -1) {\r\n            endIndex = items.length - 1\r\n          } else {\r\n            endIndex++\r\n            // Bounds\r\n            endIndex > count && (endIndex = count)\r\n          }\r\n        } else {\r\n          // Fixed size mode\r\n          startIndex = ~~(scroll.start / itemSize)\r\n          endIndex = Math.ceil(scroll.end / itemSize)\r\n\r\n          // Bounds\r\n          startIndex < 0 && (startIndex = 0)\r\n          endIndex > count && (endIndex = count)\r\n\r\n          totalSize = count * itemSize\r\n        }\r\n      }\r\n\r\n      if (endIndex - startIndex > config.itemsLimit) {\r\n        this.itemsLimitError()\r\n      }\r\n\r\n      this.totalSize = totalSize\r\n\r\n      let view\r\n\r\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\r\n\r\n      if (this.$_continuous !== continuous) {\r\n        if (continuous) {\r\n          views.clear()\r\n          unusedViews.clear()\r\n          for (let i = 0, l = pool.length; i < l; i++) {\r\n            view = pool[i]\r\n            this.unuseView(view)\r\n          }\r\n        }\r\n        this.$_continuous = continuous\r\n      } else if (continuous) {\r\n        for (let i = 0, l = pool.length; i < l; i++) {\r\n          view = pool[i]\r\n          if (view.nr.used) {\r\n            // Update view item index\r\n            if (checkItem) {\r\n              view.nr.index = items.findIndex(\r\n                item => keyField ? item[keyField] === view.item[keyField] : item === view.item,\r\n              )\r\n            }\r\n\r\n            // Check if index is still in visible range\r\n            if (\r\n              view.nr.index === -1 ||\r\n              view.nr.index < startIndex ||\r\n              view.nr.index >= endIndex\r\n            ) {\r\n              this.unuseView(view)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      const unusedIndex = continuous ? null : new Map()\r\n\r\n      let item, type, unusedPool\r\n      let v\r\n      for (let i = startIndex; i < endIndex; i++) {\r\n        item = items[i]\r\n        const key = keyField ? item[keyField] : item\r\n        if (key == null) {\r\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\r\n        }\r\n        view = views.get(key)\r\n\r\n        if (!itemSize && !sizes[i].size) {\r\n          if (view) this.unuseView(view)\r\n          continue\r\n        }\r\n\r\n        // No view assigned to item\r\n        if (!view) {\r\n          type = item[typeField]\r\n          unusedPool = unusedViews.get(type)\r\n\r\n          if (continuous) {\r\n            // Reuse existing view\r\n            if (unusedPool && unusedPool.length) {\r\n              view = unusedPool.pop()\r\n              view.item = item\r\n              view.nr.used = true\r\n              view.nr.index = i\r\n              view.nr.key = key\r\n              view.nr.type = type\r\n            } else {\r\n              view = this.addView(pool, i, item, key, type)\r\n            }\r\n          } else {\r\n            // Use existing view\r\n            // We don't care if they are already used\r\n            // because we are not in continous scrolling\r\n            v = unusedIndex.get(type) || 0\r\n\r\n            if (!unusedPool || v >= unusedPool.length) {\r\n              view = this.addView(pool, i, item, key, type)\r\n              this.unuseView(view, true)\r\n              unusedPool = unusedViews.get(type)\r\n            }\r\n\r\n            view = unusedPool[v]\r\n            view.item = item\r\n            view.nr.used = true\r\n            view.nr.index = i\r\n            view.nr.key = key\r\n            view.nr.type = type\r\n            unusedIndex.set(type, v + 1)\r\n            v++\r\n          }\r\n          views.set(key, view)\r\n        } else {\r\n          view.nr.used = true\r\n          view.item = item\r\n        }\r\n\r\n        // Update position\r\n        if (itemSize === null) {\r\n          view.position = sizes[i - 1].accumulator\r\n        } else {\r\n          view.position = i * itemSize\r\n        }\r\n      }\r\n\r\n      this.$_startIndex = startIndex\r\n      this.$_endIndex = endIndex\r\n\r\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex)\r\n\r\n      // After the user has finished scrolling\r\n      // Sort views so text selection is correct\r\n      clearTimeout(this.$_sortTimer)\r\n      this.$_sortTimer = setTimeout(this.sortViews, 300)\r\n\r\n      return {\r\n        continuous,\r\n      }\r\n    },\r\n\r\n    getListenerTarget () {\r\n      let target = scrollParent(this.$el)\r\n      // Fix global scroll target for Chrome and Safari\r\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\r\n        target = window\r\n      }\r\n      return target\r\n    },\r\n\r\n    getScroll () {\r\n      const { $el: el, direction } = this\r\n      const isVertical = direction === 'vertical'\r\n      let scrollState\r\n\r\n      if (this.pageMode) {\r\n        const bounds = el.getBoundingClientRect()\r\n        const boundsSize = isVertical ? bounds.height : bounds.width\r\n        let start = -(isVertical ? bounds.top : bounds.left)\r\n        let size = isVertical ? window.innerHeight : window.innerWidth\r\n        if (start < 0) {\r\n          size += start\r\n          start = 0\r\n        }\r\n        if (start + size > boundsSize) {\r\n          size = boundsSize - start\r\n        }\r\n        scrollState = {\r\n          start,\r\n          end: start + size,\r\n        }\r\n      } else if (isVertical) {\r\n        scrollState = {\r\n          start: el.scrollTop,\r\n          end: el.scrollTop + el.clientHeight,\r\n        }\r\n      } else {\r\n        scrollState = {\r\n          start: el.scrollLeft,\r\n          end: el.scrollLeft + el.clientWidth,\r\n        }\r\n      }\r\n\r\n      return scrollState\r\n    },\r\n\r\n    applyPageMode () {\r\n      if (this.pageMode) {\r\n        this.addListeners()\r\n      } else {\r\n        this.removeListeners()\r\n      }\r\n    },\r\n\r\n    addListeners () {\r\n      this.listenerTarget = this.getListenerTarget()\r\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive ? {\r\n        passive: true,\r\n      } : false)\r\n      this.listenerTarget.addEventListener('resize', this.handleResize)\r\n    },\r\n\r\n    removeListeners () {\r\n      if (!this.listenerTarget) {\r\n        return\r\n      }\r\n\r\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\r\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\r\n\r\n      this.listenerTarget = null\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      let scroll\r\n      if (this.itemSize === null) {\r\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\r\n      } else {\r\n        scroll = index * this.itemSize\r\n      }\r\n      this.scrollToPosition(scroll)\r\n    },\r\n\r\n    scrollToPosition (position) {\r\n      if (this.direction === 'vertical') {\r\n        this.$el.scrollTop = position\r\n      } else {\r\n        this.$el.scrollLeft = position\r\n      }\r\n    },\r\n\r\n    itemsLimitError () {\r\n      setTimeout(() => {\r\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\r\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\r\n      })\r\n      throw new Error('Rendered items limit reached')\r\n    },\r\n\r\n    sortViews () {\r\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\r\n    },\r\n  },\r\n})\r\n</script>\r\n\r\n<style>\r\n.vue-recycle-scroller {\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\r\n  overflow-y: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\r\n  overflow-x: auto;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal {\r\n  display: flex;\r\n}\r\n\r\n.vue-recycle-scroller__slot {\r\n  flex: auto 0 0;\r\n}\r\n\r\n.vue-recycle-scroller__item-wrapper {\r\n  flex: 1;\r\n  box-sizing: border-box;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\r\n\r\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  will-change: transform;\r\n}\r\n\r\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\r\n  height: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\r\n  width: 100%;\r\n}\r\n\r\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\r\n  height: 100%;\r\n}\r\n</style>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template #default=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template #before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template #after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  provide () {\r\n    let vscrollResizeObserver = undefined\r\n\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      vscrollResizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent('resize', {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver,\r\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\r\n    }\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  emits: ['vscroll:update', 'resize', 'visible'],\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n      vScrollMap: [],\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n\r\n      for (const key in this.$attrs) {\r\n        if (key.startsWith('on')) {\r\n          if (key !== 'onResize' && key !== 'onVisible') {\r\n            listeners[key] = this.$attrs\r\n          }\r\n        }\r\n      }\r\n\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.vScrollUpdate(false)\r\n      this.$emit('visible')\r\n    },\r\n\r\n    vScrollUpdate(force = false) {\r\n      const data = { force }\r\n      this.$emit('vscroll:update', data)\r\n\r\n      this.vScrollMap.forEach(callback => callback(data))\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.vScrollUpdate(true)\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","<template>\r\n  <RecycleScroller\r\n    ref=\"scroller\"\r\n    :items=\"itemsWithSize\"\r\n    :min-item-size=\"minItemSize\"\r\n    :direction=\"direction\"\r\n    key-field=\"id\"\r\n    v-bind=\"$attrs\"\r\n    @resize=\"onScrollerResize\"\r\n    @visible=\"onScrollerVisible\"\r\n    v-on=\"listeners\"\r\n  >\r\n    <template #default=\"{ item: itemWithSize, index, active }\">\r\n      <slot\r\n        v-bind=\"{\r\n          item: itemWithSize.item,\r\n          index,\r\n          active,\r\n          itemWithSize\r\n        }\"\r\n      />\r\n    </template>\r\n    <template #before>\r\n      <slot name=\"before\" />\r\n    </template>\r\n    <template #after>\r\n      <slot name=\"after\" />\r\n    </template>\r\n  </RecycleScroller>\r\n</template>\r\n\r\n<script>\r\nimport RecycleScroller from './RecycleScroller.vue'\r\nimport { props, simpleArray } from './common'\r\n\r\nexport default {\r\n  name: 'DynamicScroller',\r\n\r\n  components: {\r\n    RecycleScroller,\r\n  },\r\n\r\n  provide () {\r\n    let vscrollResizeObserver = undefined\r\n\r\n    if (typeof ResizeObserver !== 'undefined') {\r\n      vscrollResizeObserver = new ResizeObserver(entries => {\r\n        for (const entry of entries) {\r\n          if (entry.target) {\r\n            const event = new CustomEvent('resize', {\r\n                detail: {\r\n                  contentRect: entry.contentRect,\r\n                },\r\n              },\r\n            )\r\n            entry.target.dispatchEvent(event)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      vscrollData: this.vscrollData,\r\n      vscrollParent: this,\r\n      vscrollResizeObserver,\r\n      onUpdateScroll: (cb) => this.vScrollMap.push(cb),\r\n    }\r\n  },\r\n\r\n  inheritAttrs: false,\r\n\r\n  props: {\r\n    ...props,\r\n\r\n    minItemSize: {\r\n      type: [Number, String],\r\n      required: true,\r\n    },\r\n  },\r\n\r\n  emits: ['vscroll:update', 'resize', 'visible'],\r\n\r\n  data () {\r\n    return {\r\n      vscrollData: {\r\n        active: true,\r\n        sizes: {},\r\n        validSizes: {},\r\n        keyField: this.keyField,\r\n        simpleArray: false,\r\n      },\r\n      vScrollMap: [],\r\n    }\r\n  },\r\n\r\n  computed: {\r\n    simpleArray,\r\n\r\n    itemsWithSize () {\r\n      const result = []\r\n      const { items, keyField, simpleArray } = this\r\n      const sizes = this.vscrollData.sizes\r\n      for (let i = 0; i < items.length; i++) {\r\n        const item = items[i]\r\n        const id = simpleArray ? i : item[keyField]\r\n        let size = sizes[id]\r\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\r\n          size = 0\r\n        }\r\n        result.push({\r\n          item,\r\n          id,\r\n          size,\r\n        })\r\n      }\r\n      return result\r\n    },\r\n\r\n    listeners () {\r\n      const listeners = {}\r\n\r\n      for (const key in this.$attrs) {\r\n        if (key.startsWith('on')) {\r\n          if (key !== 'onResize' && key !== 'onVisible') {\r\n            listeners[key] = this.$attrs\r\n          }\r\n        }\r\n      }\r\n\r\n      return listeners\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    items () {\r\n      this.forceUpdate(false)\r\n    },\r\n\r\n    simpleArray: {\r\n      handler (value) {\r\n        this.vscrollData.simpleArray = value\r\n      },\r\n      immediate: true,\r\n    },\r\n\r\n    direction (value) {\r\n      this.forceUpdate(true)\r\n    },\r\n  },\r\n\r\n  created () {\r\n    this.$_updates = []\r\n    this.$_undefinedSizes = 0\r\n    this.$_undefinedMap = {}\r\n  },\r\n\r\n  activated () {\r\n    this.vscrollData.active = true\r\n  },\r\n\r\n  deactivated () {\r\n    this.vscrollData.active = false\r\n  },\r\n\r\n  methods: {\r\n    onScrollerResize () {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) {\r\n        this.forceUpdate()\r\n      }\r\n      this.$emit('resize')\r\n    },\r\n\r\n    onScrollerVisible () {\r\n      this.vScrollUpdate(false)\r\n      this.$emit('visible')\r\n    },\r\n\r\n    vScrollUpdate(force = false) {\r\n      const data = { force }\r\n      this.$emit('vscroll:update', data)\r\n\r\n      this.vScrollMap.forEach(callback => callback(data))\r\n    },\r\n\r\n    forceUpdate (clear = true) {\r\n      if (clear || this.simpleArray) {\r\n        this.vscrollData.validSizes = {}\r\n      }\r\n      this.vScrollUpdate(true)\r\n    },\r\n\r\n    scrollToItem (index) {\r\n      const scroller = this.$refs.scroller\r\n      if (scroller) scroller.scrollToItem(index)\r\n    },\r\n\r\n    getItemSize (item, index = undefined) {\r\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\r\n      return this.vscrollData.sizes[id] || 0\r\n    },\r\n\r\n    scrollToBottom () {\r\n      if (this.$_scrollingToBottom) return\r\n      this.$_scrollingToBottom = true\r\n      const el = this.$el\r\n      // Item is inserted to the DOM\r\n      this.$nextTick(() => {\r\n        el.scrollTop = el.scrollHeight + 5000\r\n        // Item sizes are computed\r\n        const cb = () => {\r\n          el.scrollTop = el.scrollHeight + 5000\r\n          requestAnimationFrame(() => {\r\n            el.scrollTop = el.scrollHeight + 5000\r\n            if (this.$_undefinedSizes === 0) {\r\n              this.$_scrollingToBottom = false\r\n            } else {\r\n              requestAnimationFrame(cb)\r\n            }\r\n          })\r\n        }\r\n        requestAnimationFrame(cb)\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n","import { createVNode, nextTick } from 'vue';\r\n\r\nexport default {\r\n  name: 'DynamicScrollerItem',\r\n\r\n  inject: [\r\n    'vscrollData',\r\n    'vscrollParent',\r\n    'onUpdateScroll',\r\n    'vscrollResizeObserver',\r\n  ],\r\n\r\n  props: {\r\n    item: {\r\n      required: true,\r\n    },\r\n\r\n    watchData: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    /**\r\n     * Indicates if the view is actively used to display an item.\r\n     */\r\n    active: {\r\n      type: Boolean,\r\n      required: true,\r\n    },\r\n\r\n    index: {\r\n      type: Number,\r\n      default: undefined,\r\n    },\r\n\r\n    sizeDependencies: {\r\n      type: [Array, Object],\r\n      default: null,\r\n    },\r\n\r\n    emitResize: {\r\n      type: Boolean,\r\n      default: false,\r\n    },\r\n\r\n    tag: {\r\n      type: String,\r\n      default: 'div',\r\n    },\r\n  },\r\n\r\n  computed: {\r\n    id () {\r\n      return this.vscrollData.simpleArray ? this.index : this.item[this.vscrollData.keyField];\r\n    },\r\n\r\n    size () {\r\n      return (this.vscrollData.validSizes[this.id] && this.vscrollData.sizes[this.id]) || 0;\r\n    },\r\n\r\n    finalActive () {\r\n      return this.active && this.vscrollData.active;\r\n    },\r\n  },\r\n\r\n  watch: {\r\n    watchData: 'updateWatchData',\r\n\r\n    id () {\r\n      if (!this.size) {\r\n        this.onDataUpdate();\r\n      }\r\n    },\r\n\r\n    finalActive (value) {\r\n      if (!this.size) {\r\n        if (value) {\r\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes++;\r\n            this.vscrollParent.$_undefinedMap[this.id] = true;\r\n          }\r\n        } else {\r\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n            this.vscrollParent.$_undefinedSizes--;\r\n            this.vscrollParent.$_undefinedMap[this.id] = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this.vscrollResizeObserver) {\r\n        if (value) {\r\n          this.observeSize();\r\n        } else {\r\n          this.unobserveSize();\r\n        }\r\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\r\n        this.updateSize();\r\n      }\r\n    },\r\n  },\r\n\r\n  created () {\r\n    if (this.$isServer) return;\r\n\r\n    this.$_forceNextVScrollUpdate = null;\r\n    this.updateWatchData();\r\n\r\n    if (!this.vscrollResizeObserver) {\r\n      for (const k in this.sizeDependencies) {\r\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);\r\n      }\r\n\r\n      this.onUpdateScroll('vscroll:update', this.onVscrollUpdate);\r\n    }\r\n  },\r\n\r\n  mounted () {\r\n    if (this.vscrollData.active) {\r\n      this.updateSize();\r\n      this.observeSize();\r\n    }\r\n  },\r\n\r\n  beforeUnmount () {\r\n    this.unobserveSize();\r\n  },\r\n\r\n  methods: {\r\n    updateSize () {\r\n      if (this.finalActive) {\r\n        if (this.$_pendingSizeUpdate !== this.id) {\r\n          this.$_pendingSizeUpdate = this.id;\r\n          this.$_forceNextVScrollUpdate = null;\r\n          this.$_pendingVScrollUpdate = null;\r\n          this.computeSize(this.id);\r\n        }\r\n      } else {\r\n        this.$_forceNextVScrollUpdate = this.id;\r\n      }\r\n    },\r\n\r\n    updateWatchData () {\r\n      if (this.watchData) {\r\n        this.$_watchData = this.$watch('data', () => {\r\n          this.onDataUpdate();\r\n        }, {\r\n          deep: true,\r\n        });\r\n      } else if (this.$_watchData) {\r\n        this.$_watchData();\r\n        this.$_watchData = null;\r\n      }\r\n    },\r\n\r\n    onVscrollUpdate ({ force }) {\r\n      // If not active, sechedule a size update when it becomes active\r\n      if (!this.finalActive && force) {\r\n        this.$_pendingVScrollUpdate = this.id;\r\n      }\r\n\r\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\r\n        this.updateSize();\r\n      }\r\n    },\r\n\r\n    onDataUpdate () {\r\n      this.updateSize();\r\n    },\r\n\r\n    computeSize (id) {\r\n      nextTick(() => {\r\n        if (this.id === id) {\r\n          const width = this.$el.offsetWidth;\r\n          const height = this.$el.offsetHeight;\r\n          this.applySize(width, height);\r\n        }\r\n        this.$_pendingSizeUpdate = null;\r\n      }).then();\r\n    },\r\n\r\n    applySize (width, height) {\r\n      const size = Math.round(this.vscrollParent.direction === 'vertical' ? height : width);\r\n      if (size && this.size !== size) {\r\n        if (this.vscrollParent.$_undefinedMap[this.id]) {\r\n          this.vscrollParent.$_undefinedSizes--;\r\n          this.vscrollParent.$_undefinedMap[this.id] = undefined;\r\n        }\r\n        this.vscrollData.sizes[this.id] = size;\r\n        this.vscrollData.validSizes[this.id] = true;\r\n        if (this.emitResize) this.$emit('resize', this.id);\r\n      }\r\n    },\r\n\r\n    observeSize () {\r\n      if (!this.vscrollResizeObserver) return;\r\n      this.vscrollResizeObserver.observe(this.$el.parentNode);\r\n      this.$el.parentNode.addEventListener('resize', this.onResize);\r\n    },\r\n\r\n    unobserveSize () {\r\n      if (!this.vscrollResizeObserver) return;\r\n      this.vscrollResizeObserver.unobserve(this.$el.parentNode);\r\n      this.$el.parentNode.removeEventListener('resize', this.onResize);\r\n    },\r\n\r\n    onResize (event) {\r\n      const { width, height } = event.detail.contentRect;\r\n      this.applySize(width, height);\r\n    },\r\n  },\r\n\r\n  render () {\r\n    return createVNode(this.tag, null, this.$slots.default());\r\n  },\r\n};\r\n","import config from './config'\r\n\r\nimport RecycleScroller from './components/RecycleScroller.vue'\r\nimport DynamicScroller from './components/DynamicScroller.vue'\r\nimport DynamicScrollerItem from './components/DynamicScrollerItem.js'\r\nimport { version } from '../package.json'\r\n\r\nexport {\r\n  RecycleScroller,\r\n  DynamicScroller,\r\n  DynamicScrollerItem,\r\n}\r\n\r\nfunction registerComponents (app, prefix) {\r\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\r\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\r\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\r\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\r\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\r\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\r\n}\r\n\r\nconst plugin = {\r\n  version,\r\n  install (app, options) {\r\n    const finalOptions = Object.assign({}, {\r\n      installComponents: true,\r\n      componentsPrefix: '',\r\n    }, options)\r\n\r\n    for (const key in finalOptions) {\r\n      if (typeof finalOptions[key] !== 'undefined') {\r\n        config[key] = finalOptions[key]\r\n      }\r\n    }\r\n\r\n    if (finalOptions.installComponents) {\r\n      registerComponents(app, finalOptions.componentsPrefix)\r\n    }\r\n  },\r\n}\r\n\r\nexport default plugin\r\n"],"names":["itemsLimit","isIE","initCompat","init","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","rv","edge","getInternetExplorerVersion","script","name","props","showTrigger","type","Boolean","default","emits","[object Object]","emit","_w","_h","elRef","ref","_resizeObject","compareAndNotify","value","offsetWidth","offsetHeight","width","height","addResizeHandlers","contentDocument","defaultView","addEventListener","onMounted","object","document","createElement","setAttribute","onload","appendChild","data","onBeforeUnmount","removeEventListener","removeChild","_hoisted_1","class","tabindex","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_toConsumableArray","arr","Array","isArray","arr2","_arrayWithoutHoles","iter","toString","call","from","_iterableToArray","TypeError","_nonIterableSpread","render","_ctx","_cache","$props","$setup","$data","$options","openBlock","createBlock","__file","install","app","component","VisibilityState","el","options","vnode","instance","Constructor","_classCallCheck","this","observer","frozen","createObserver","protoProps","staticProps","_this","destroyObserver","callback","result","entry","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","arguments","undefined","throttled","state","_len","args","_key","apply","concat","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","get","mounted","_ref2","console","warn","_vue_visibilityState","unmounted","ObserveVisibility","componentUpdated","_ref3","deepEqual","val1","val2","oldValue","items","required","keyField","String","direction","validator","includes","scrollParent","node","regex","style","prop","getComputedStyle","getPropertyValue","scroll","test","overflow","HTMLElement","SVGElement","ps","parents","parentNode","scrollingElement","documentElement","simpleArray","supportsPassive","opts","uid","defineComponent","components","ResizeObserver","directives","itemSize","Number","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","pool","totalSize","ready","hoverKey","computed","sizes","current","accumulator","field","computedMinSize","l","size","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","handler","deep","created","$_startIndex","$_endIndex","$_views","Map","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","$nextTick","beforeUnmount","removeListeners","methods","addView","index","item","view","position","nr","id","used","push","unuseView","fake","unusedViews","unusedPool","set","delete","handleResize","$emit","handleScroll","event","requestAnimationFrame","_this2","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","_this3","checkItem","startIndex","endIndex","checkPositionDiff","count","views","getScroll","positionDiff","start","end","oldI","a","b","Math","ceil","config","itemsLimitError","$_continuous","clear","findIndex","v","unusedIndex","Error","pop","$_sortTimer","sortViews","getListenerTarget","$el","body","scrollState","isVertical","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","scrollToPosition","log","_this4","sort","viewA","viewB","_createBlock","before","_renderSlot","_createVNode","onMouseenter","onMouseleave","active","after","_hoisted_2","onNotify","RecycleScroller","provide","vscrollResizeObserver","CustomEvent","detail","contentRect","dispatchEvent","vscrollData","vscrollParent","onUpdateScroll","cb","vScrollMap","inheritAttrs","validSizes","itemsWithSize","$_undefinedMap","listeners","$attrs","startsWith","forceUpdate","immediate","$_updates","$_undefinedSizes","activated","deactivated","onScrollerResize","$refs","scroller","onScrollerVisible","vScrollUpdate","force","forEach","getItemSize","scrollToBottom","$_scrollingToBottom","scrollHeight","_mergeProps","onResize","onVisible","_toHandlers","itemWithSize","inject","watchData","sizeDependencies","emitResize","tag","finalActive","onDataUpdate","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","onVscrollUpdate","$_pendingSizeUpdate","computeSize","$_watchData","nextTick","applySize","then","round","unobserve","createVNode","$slots","plugin","version","finalOptions","assign","installComponents","componentsPrefix","prefix","DynamicScroller","DynamicScrollerItem","registerComponents"],"mappings":"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"}